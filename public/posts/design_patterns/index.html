<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/blog3/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog3/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Design Patterns | Geoffrey 2</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="C’est quoi ?
Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :

Limiter le couplage
Faciliter la maintenance
Être moins rigide face au changement

Ils sont indispensables à connaître pour le développeur :

Pour s’assurer d’une meilleure conception
Pour dialoguer avec les développeurs (à travers le “langage pattern”)
Pour comprendre les frameworks

Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">
    <meta name="generator" content="Hugo 0.143.1">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/blog3/ananke/css/main.min.css" >




    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/blog3/posts/design_patterns/">
    

    <meta property="og:url" content="http://localhost:1313/blog3/posts/design_patterns/">
  <meta property="og:site_name" content="Geoffrey 2">
  <meta property="og:title" content="Design Patterns">
  <meta property="og:description" content="C’est quoi ? Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :
Limiter le couplage Faciliter la maintenance Être moins rigide face au changement Ils sont indispensables à connaître pour le développeur :
Pour s’assurer d’une meilleure conception Pour dialoguer avec les développeurs (à travers le “langage pattern”) Pour comprendre les frameworks Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-24T17:49:47+02:00">
    <meta property="article:modified_time" content="2023-04-24T17:49:47+02:00">
    <meta property="article:tag" content="Design Patterns">
    <meta property="article:tag" content="Cours">

  <meta itemprop="name" content="Design Patterns">
  <meta itemprop="description" content="C’est quoi ? Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :
Limiter le couplage Faciliter la maintenance Être moins rigide face au changement Ils sont indispensables à connaître pour le développeur :
Pour s’assurer d’une meilleure conception Pour dialoguer avec les développeurs (à travers le “langage pattern”) Pour comprendre les frameworks Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">
  <meta itemprop="datePublished" content="2023-04-24T17:49:47+02:00">
  <meta itemprop="dateModified" content="2023-04-24T17:49:47+02:00">
  <meta itemprop="wordCount" content="1750">
  <meta itemprop="keywords" content="Design Patterns,Cours">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Design Patterns">
  <meta name="twitter:description" content="C’est quoi ? Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :
Limiter le couplage Faciliter la maintenance Être moins rigide face au changement Ils sont indispensables à connaître pour le développeur :
Pour s’assurer d’une meilleure conception Pour dialoguer avec les développeurs (à travers le “langage pattern”) Pour comprendre les frameworks Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/blog3/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Geoffrey 2
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Design Patterns</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-04-24T17:49:47+02:00">April 24, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="cest-quoi-">C’est quoi ?</h2>
<p>Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :</p>
<ul>
<li>Limiter le couplage</li>
<li>Faciliter la maintenance</li>
<li>Être moins rigide face au changement</li>
</ul>
<p>Ils sont indispensables à connaître pour le développeur :</p>
<ul>
<li>Pour s’assurer d’une meilleure conception</li>
<li>Pour dialoguer avec les développeurs (à travers le “langage pattern”)</li>
<li>Pour comprendre les frameworks</li>
</ul>
<p>Un livre écrit par le <a href="https://fr.wikipedia.org/wiki/Patron_de_conception">GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)</a> décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :</p>
<h2 id="creational-patterns">Creational patterns</h2>
<p>Les patterns de <strong>création</strong>, relatifs à la création d’objet.</p>
<h3 id="singleton">Singleton</h3>
<p>Une seule instance d’une classe.</p>
<h3 id="prototype">Prototype</h3>
<ul>
<li>Clone,</li>
<li>Héritage de prototype</li>
</ul>
<h3 id="builder">Builder</h3>
<ul>
<li>Construire un objet avec plusieurs éléments choisi (recette de cuisine).</li>
<li>Permet de construire un objet complexe étape par étape.</li>
<li>Le constructeur est appelé à chaque étape de la construction de l&rsquo;objet.</li>
<li>Le client n&rsquo;a pas besoin de connaître les étapes de construction de l&rsquo;objet, il suffit de lui fournir un objet de construction. Le pattern Builder est utilisé pour construire des objets complexes étape par étape. Il permet de séparer la construction d&rsquo;un objet complexe de sa représentation finale, de sorte que le même processus de construction puisse créer différentes représentations.</li>
</ul>
<h3 id="factory">Factory</h3>
<p>Fabrique des objets en fonction d’un paramètre.</p>
<h3 id="abstract-factory">Abstract factory</h3>
<p>Fabrique des objets en fonction d’un paramètre, mais avec plusieurs usines, Par exemple pour implémenter une charte graphique : il existe une fabrique qui retourne des objets (boutons, menus) dans le style de Windows, une qui retourne des objets dans le style de Motif, et une dans le style de Macintosh. Une fabrique abstraite est obtenue en utilisant une fabrique simple.</p>
<h2 id="structural-patterns">Structural patterns</h2>
<p>Les patterns <strong>structuraux</strong>, qui structurent l’organisation des classes entre elles, comment elles sont liées.</p>
<h3 id="adapter">Adapter</h3>
<p>Adapte une interface à une autre:</p>
<ul>
<li>On veut utiliser une classe existante, mais dont l’interface ne coïncide pas avec celle escompté.</li>
<li>On souhaite créer une classe réutilisable qui collabore avec des classes sans relations avec elle et encore inconnues, c’est-à-dire avec des classes qui n’auront pas nécessairement des interfaces compatibles.</li>
<li>On a besoin d’utiliser plusieurs sous-classes existantes, mais l’adaptation de leur interface par dérivation de chacune d’entre elles est impraticable. Un adaptateur peut adapter l’interface de sa classe parente.</li>
</ul>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

abstract Cible{
 + requete()
}

Adaptateur : + requete()
Adapté : + requeteSpécifique()
note &#34;requeteSpécifique()&#34; as N1


Client -&gt; Cible
Cible &lt;|-- Adaptateur
Adapté &lt;-- Adaptateur
Adaptateur . N1


@enduml
</code></pre><h3 id="composite">Composite</h3>
<p>Permet d’agencer les objets dans des arborescences afin de pouvoir traiter de la même et unique façon les objets individuels et les combinaisons de ceux-ci. <em>un objet contient d’autres objets</em> :</p>
<ul>
<li>Un système de fichier</li>
<li>Des objets graphiques (conteneurs et éléments graphiques élémentaire)</li>
<li>DOM</li>
</ul>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml
skinparam groupInheritance 2

class Client {
    + main()
}

abstract Composant {
    + opération()
    + ajouter(c: Composant)
    + supprimer(c: Composant)
    + getEnfant(i: int)
}

class Feuille{
    + opération()
}

class Composite{
    + opération()
    + ajoute(c: Composant)
    + supprimer(c Composant)
    + getEnfant(i; Int)
}

note &#34;pour tout g parmi enfant g.opération();&#34; as N

Client -&gt; Composant
Composant &lt;|-- Feuille
Composant &lt;|-- Composite
Composant &#34;1..*&#34;&lt;-- Composite
Composite .. N

@enduml
</code></pre><h3 id="decorator">Decorator</h3>
<p>Un objet contient un autre objet, et ajoute des fonctionnalités <em>surchargeant les méthodes.</em>
Permet d&rsquo;ajouter des fonctionnalités à un objet de manière dynamique.</p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

abstract Composant{
 + opération()
}

ComposantConcret : + opération()

abstract Décorateur{
 + opération()
}

class DécorateurConcretA{
 - étatAjouté : int
 + oprétion()
}

class DécorateurConcretB{
 + opération()
 + comportementAjouté()
}

note right of Décorateur : composant.opération()
note right of DécorateurConcretB : Décoration.opération();\ncomportementAjouté();

Composant &lt;|- ComposantConcret
Composant &lt;|-- Décorateur
Composant &lt;-- Décorateur
Décorateur &lt;|-- DécorateurConcretA
Décorateur &lt;|-- DécorateurConcretB
@enduml
</code></pre><h3 id="facade">Facade</h3>
<p>Permet de fournir une interface unifiée pour un ensemble d&rsquo;interfaces dans un sous-système.</p>
<h2 id="behavioral-patterns">Behavioral patterns</h2>
<p>Les patterns <strong>comportementaux</strong>, qui définissent la communication entre objets.</p>
<h3 id="strategy">Strategy</h3>
<p>Permet de définir une famille d&rsquo;algorithmes, encapsuler chacun d&rsquo;eux et les rendre interchangeables. En général, les clients créent un objet StrategieConcrete, et le passent au contexte, par la suite les clients interagissent exclusivement avec le contexte.</p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

class contexte{
 + interfaceContexte()
}

Abstract Stratégie{
 + interfaceAlgorithme()
}

StratégieConcrèteA : + interfaceAlgorithme()
StratégieConcrèteB : + interfaceAlgorithme()
StratégieConcrèteC : + interfaceAlgorithme()



contexte -&gt; Stratégie
 Stratégie &lt;|-- StratégieConcrèteA
 Stratégie &lt;|-- StratégieConcrèteB
 Stratégie &lt;|-- StratégieConcrèteC

@enduml
</code></pre><h3 id="command">Command</h3>
<p>Un objet encapsule une commande, et peut l’exécuter, encapsuler une demande sous la forme d&rsquo;un objet, ce qui permet de paramétrer les clients avec différentes demandes.</p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml



abstract Commande {
    + execute()
}

class CommandeConcrete{
    + execute()
}
class Recepteur {
    + action()
}

note &#34;Recepteur.action()&#34; as N1

Invocateur -&gt; Commande
Commande &lt;|-- CommandeConcrete

Client .&gt; CommandeConcrete 
Client -&gt; Recepteur
CommandeConcrete --&gt; Recepteur
CommandeConcrete .. N1




@enduml
</code></pre><h3 id="iterator">Iterator</h3>
<p>Permets de parcourir les éléments d’une collection sans révéler sa représentation interne (liste, pile, arbre, etc.).
Même appel pour n&rsquo;importe quel type de collection, en java on utilise l&rsquo;interface Iterable et l&rsquo;interface Iterator
<code>java.util.Iterator</code> et <code>java.lang.Iterable</code></p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml



class Client {
    + main()
}

interface Iterateur{
 + suivant()
 + existeSuivant()
 + supprimer()
}

abstract Agregat{
 {abstract} + créeItérateur()
}

class AgregatContret{
 + créeItérateur()
}



Agregat &lt;-Client
Client -&gt; Iterateur
Agregat &lt;|-- AgregatContret
Iterateur &lt;|-- ItérateurConcret
AgregatContret -&gt; ItérateurConcret

note &#34;return new ItérateurConcret(this)&#34; as N1
AgregatContret .. N1



@enduml
</code></pre><h3 id="observer">Observer</h3>
<p>Permet à un objet de surveiller l&rsquo;état d&rsquo;un autre objet et d&rsquo;être informé lorsque cet état change, Le design pattern Observer est utilisé pour établir une relation de type &ldquo;un-à-plusieurs&rdquo; entre des objets, où un objet principal, appelé &ldquo;sujet&rdquo; (ou &ldquo;observable&rdquo;), informe plusieurs autres objets, appelés &ldquo;observateurs&rdquo;, lorsqu&rsquo;il subit un changement d&rsquo;état. L&rsquo;idée est de définir une relation de dépendance entre ces objets sans les coupler de manière rigide. Cela permet de mettre à jour automatiquement les observateurs lorsque le sujet change d&rsquo;état, sans avoir à les relier explicitement.</p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

abstract Sujet{
 + attache(o : Observateur)
 + détache(o : Observateur)
 + notifie()
}

abstract Observateur{
 + miseAJour()
}

ObservateurConcret : + miseAJour()
note &#34;Pour tout o dans Observateurs\n o.miseAJour()&#34; as N


Sujet -&gt; Observateur
Sujet &lt;|-- SujetConcret 
Observateur &lt;|-- ObservateurConcret 
Sujet .. N

@enduml
</code></pre><h3 id="mediator">Mediator</h3>
<p>Un objet centralise la communication entre plusieurs, objets, associe un objet à un autre (centrale d&rsquo;avion).</p>
<h3 id="state">State</h3>
<p>Un objet change de comportement en fonction de son état (ex: un bouton qui change de couleur en fonction de son état).
Modélise des objets dont le comportement varie en fonction de leur état interne. L&rsquo;idée est de définir une classe abstraite représentant l&rsquo;état général d&rsquo;un objet, et des sous-classes concrètes représentant les différents états spécifiques. Chaque état peut définir ses propres comportements pour les différentes méthodes de l&rsquo;objet. L&rsquo;objet principal, appelé &ldquo;contexte&rdquo;, maintient une référence à un objet d&rsquo;état particulier, qui détermine le comportement actuel de l&rsquo;objet. En modifiant l&rsquo;état du contexte, on peut modifier le comportement de l&rsquo;objet.</p>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

Contexte : + requette()

abstract État{
 + gerer(): void
}

ÉtatAConcret : + gerer()
ÉtatBConcret : + gerer()

note bottom of Contexte : etat.gerer()

Contexte -&gt; État
État &lt;|-- ÉtatAConcret
État &lt;|-- ÉtatBConcret

@enduml
</code></pre><h3 id="visitor">Visitor</h3>
<p>Utilisez le pattern Visiteur quand vous voulez ajouter des capacités à un ensemble composite d’objets et que l’encapsulation n’est pas importante.
Le Visiteur doit parcourir chaque élément du Composite : cette fonctionnalité se trouve dans un objet Navigateur. Le Visiteur est guidé par le Navigateur et recueille l’état de tous les objets du Composite. Une fois l’état recueilli, le Client peut demander au Visiteur d’exécuter différentes opérations sur celui-ci. Quand une nouvelle fonctionnalité est requise, seul le Visiteur doit être modifié.</p>
<ul>
<li>Permet d’ajouter des opérations à la structure d’un Composite sans modifier la structure elle-même.</li>
<li>L’encapsulation des classes du Composite est brisée.</li>
<li>Comme une fonction de navigation est impliquée, les modifications de la structure du Composite sont plus difficiles.</li>
</ul>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml

abstract Visiteur{
 + visiteurElementconcretA(elemConcretA)
 + visiteurElementconcretB(elemConcretB)
}

class VisiteurConcrèt1{
 + visiteurElementconcretA(elemConcretA)
 + visiteurElementconcretB(elemConcretB)
}

class VisiteurConcrèt2{
 + visiteurElementconcretA(elemConcretA)
 + visiteurElementconcretB(elemConcretB)
}

abstract Élement{
 + accept(v: Visiteur)
}

class ÉlementConcrètA{
 + accept(v: Visiteur)
 + opérationA()
}

class ÉlementConcrètB{
 + accept(v: Visiteur)
 + opérationB()
}


note &#34;v.visiteElelementConcretA()&#34; as N
note &#34;v.visiteElelementConcretB()&#34; as N2

Client -&gt; Visiteur
Visiteur &lt;|-- VisiteurConcrèt1
Visiteur &lt;|-- VisiteurConcrèt2
Client ---&gt; StuctureDObjet
StuctureDObjet -&gt; Élement
Élement &lt;|-- ÉlementConcrètA
Élement &lt;|-- ÉlementConcrètB

ÉlementConcrètA . N
ÉlementConcrètB . N2

@enduml
</code></pre><h2 id="les-inconvénients-des-patterns">Les inconvénients des patterns</h2>
<ul>
<li>Ils occasionnent plus de classes</li>
<li>Ils peuvent être peu adaptés dans des environnements dit “limités” (comme Android)</li>
<li>c’est à encapsuler ce qui varie.</li>
<li>Ce principe nous enseigne à limiter chaque classe à une seule responsabilité. (Cohésion)</li>
<li>Nous savons que nous devons éviter comme la peste de changer quelque chose à une classe (Couplage)</li>
</ul>
<h2 id="autres-patrons-de-conception">Autres patrons de conception</h2>
<h3 id="object-pool">Object Pool</h3>
<p>Ce patron permet d&rsquo;économiser les temps d&rsquo;instanciation et de suppression lorsque de nombreux objets ont une courte durée d&rsquo;utilisation. Il consiste à administrer une collection d&rsquo;objets qui peuvent être recyclés. Une méthode du Pool délivre un objet soit par une nouvelle instanciation, soit par recyclage d&rsquo;un objet périmé. Lorsque les objets arrivent à la fin de leur cycle de vie, ils sont remis à la disposition du Pool pour un futur recyclage. Dans la phase d&rsquo;instanciation, le Pool peut instancier plus d&rsquo;un objet à la fois si l&rsquo;algorithme d&rsquo;instanciation a une complexité meilleure que O(n). Le patron Object Pool est particulièrement utile lorsque le nombre total de cycles de vie est très grand devant le nombre d&rsquo;instances à un moment précis et que les opérations d&rsquo;instanciation et/ou suppression sont coûteuses en temps d&rsquo;exécution par rapport à leur recyclage.</p>
<h3 id="modèle-vue-contrôleur">Modèle-vue-contrôleur</h3>
<p>Combinaison des patrons observateur, stratégie et composite, ce qui forme ainsi un patron d&rsquo;architecture.</p>
<h3 id="inversion-de-contrôle">Inversion de contrôle</h3>
<h3 id="injection-de-dépendances">Injection de dépendances</h3>
<h2 id="les-principes-de-conception-orientée-objet">Les principes de conception Orientée Objet</h2>
<h3 id="principe-ouvert-fermé">Principe Ouvert-Fermé</h3>
<blockquote>
<p>Les classes doivent être ouvertes à l’extension mais fermées au changement.</p></blockquote>
<ul>
<li>Ouvert à l’ajout de code</li>
<li>Fermé aux modifications du code existant</li>
<li>Ne pas modifier le code qui fonctionne, ce qui est stable doit rester stable.</li>
</ul>
<h3 id="principe-dinversion-des-dépendances">Principe d’inversion des dépendances</h3>
<blockquote>
<p>Dépendez des abstractions et non des classes concrètes.</p></blockquote>
<ul>
<li>Les modules de haut niveau ne doivent pas dépendre des classes concrètes d’un module de bas niveau</li>
<li>Les deux doivent dépendre d’abstraction</li>
</ul>
<h3 id="principe-dhollywood">Principe d’Hollywood</h3>
<blockquote>
<p>“Ne nous appelez pas, nous vous appelerons.”</p></blockquote>
<p>Les composants de bas niveau doivent s’adapter à un système, mais ce sont les composants de haut niveau qui déterminent quand appeler les composants de bas niveau.</p>
<p>Hollywood correspond aux composants de haut niveau, les acteurs correspondent aux composants de bas niveau. C’est Hollywood qui appelle les acteurs.</p>
<h3 id="autres-principes-en-vrac">Autres principes en vrac</h3>
<ul>
<li>Programmez des interfaces</li>
<li>Encapsulez ce qui varie</li>
<li>Couplez faiblement vos objets</li>
<li>Préférez la composition à l’héritage (“à un” plutôt que “est un”)</li>
<li>Une classe = Une responsabilité</li>
<li>Qui est responsable de ?</li>
</ul>
<hr>
<h2 id="source">source</h2>
<ul>
<li>wikipedia</li>
<li>headfirst : design patterns</li>
<li>mes cours</li>
<li>Fiche de revision de Théo</li>
</ul>
<ul class="pa0">
  
   <li class="list di">
     <a href="/blog3/tags/design-patterns/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Design Patterns</a>
   </li>
  
   <li class="list di">
     <a href="/blog3/tags/cours/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Cours</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/blog3/" >
    &copy;  Geoffrey 2 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
